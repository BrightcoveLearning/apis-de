---
title: 'Katalogsuche Architektur'
description: 'In diesem Thema erfahren Sie mehr über die Architektur der Katalogsuchtechnologie, die sowohl für die CMS- als auch für die Playback-APIs verwendet wird.'
parent: Guides 
grandparent: Playback API
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>
    <section class="bcls-section">
    <h2 id="Overview">Überblick</h2>
    
    <p >Ab April 2019 wurde die Katalogsuchfunktionalität auf Elasticsearch aktualisiert. Dieses Upgrade bietet eine Reihe von Vorteilen, darunter vor allem eine verbesserte Relevanz und Genauigkeit sowie eine dramatisch verbesserte Leistung – die Reaktionszeit ist viel konsistenter und im Allgemeinen doppelt so schnell. Diese neue Funktionalität wirkt sich auf die CMS-API, die Wiedergabe-API, die interaktive Studio-Suche und die Katalogsuchmethoden aus.</p>
    
    <p >Obwohl Brightcove erhebliche Anstrengungen unternommen hat, um die Ergebnisse von Elasticsearch konsistent zu machen, gibt es Unterschiede, und es besteht die geringe Möglichkeit, dass sich Ihre Integration möglicherweise nicht wie erwartet verhält, wenn Sie bestimmte Abhängigkeiten von Suchergebnissen codiert haben.</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="Search_Result_Differences_and_Impact">Unterschiede in den Suchergebnissen und Auswirkungen</h2>
    
    <p >Bei der Untersuchung der potenziellen Auswirkungen hat Brightcove festgestellt, dass mehr als 90 % der Suchanfragen Ergebnisse liefern, die in Bezug auf die Anzahl der zurückgegebenen Ergebnisse übereinstimmen. Dies ist ein Indikator dafür, dass die erwarteten Ergebnisse nicht genug unterschiedlich sein sollten, um Probleme mit API-Integrationen zu verursachen.</p>
    
    <figure class="bcls-figure"><img class="bcls-image" alt="comparison" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/elasticsearch/comparison.png" /></figure>
    
    <p >Dieses Diagramm zeigt die Anzahl der Suchergebnisse, die genau der Anzahl der Ergebnisse zwischen den beiden Systemen entsprechen, in Blau und diejenigen, die sich in der Anzahl unterscheiden, in Rot.</p>
    
    <p >Im Rahmen unseres Roll-outs werden alle Standardsuchen, also die Suchen nach dem leeren String, bereits seit mehreren Monaten von Elasticsearch bereitgestellt – sodass Benutzer Elasticsearch-Ergebnisse bereits jetzt ohne Probleme sehen und verwenden können.</p>
    
    <p >Es gibt jedoch Einschränkungen bei dem, was wir aus dieser Art von Vergleich lernen können. Wir können bestenfalls nur auf die Absicht einer bestimmten Suche schließen, und Katalogdaten sind fließend.</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="Known_Differences">Bekannte Unterschiede</h2>
    
    <p >Die folgenden Unterschiede sind größtenteils grundlegend oder das Ergebnis von Entscheidungen, die nach einer ausführlichen Analyse der Suchergebnisse getroffen wurden – sie können nicht vollständig beseitigt werden.</p>
    
    <h3>Stemmen</h3>
    
    <p ><a href="https://en.wikipedia.org/wiki/Stemming">Stemmen</a> ist der Prozess der Reduzierung gebeugter (oder manchmal abgeleiteter) Wörter auf ihre <a href="https://en.wikipedia.org/wiki/Word_stem">Wortstamm</a> , Basis oder <a href="https://en.wikipedia.org/wiki/Root_(linguistics)">Wurzel</a> form – im Allgemeinen eine geschriebene Wortform.</p>
    
    <p >Ein Stemmer für Englisch, der am Stiel operiert <em>Katze</em> sollte solche identifizieren <a href="https://en.wikipedia.org/wiki/String_literal">Saiten</a> wie <em>Katzen</em>, <em>katzenartig</em> und <em>kitschig</em>. Ein Stemming-Algorithmus könnte auch die Wörter reduzieren <em>Angeln</em>, <em>gefischt</em> und <em>Fischer</em> zum Stiel <em>Fisch</em>. Der Stamm muss kein Wort sein, zum Beispiel reduziert der Porter-Algorithmus <em>argumentieren</em>, <em>argumentierte</em>, <em>argumentiert</em>, <em>streiten</em> und <em>argus</em> zum Stiel <em>argumentieren</em>.</p>
    
    <p >Unsere bestehende Suche verwendet den Lancaster (Paice/Husk) Stemmer, dieser Algorithmus wird im Allgemeinen als zu aggressiv angesehen – dies führt zum Beispiel zu mangelnder Unterscheidung <em>Feuerzeug</em> und <em>hell</em> würde unter Lancaster als der gleiche Begriff angesehen werden.</p>
    
    <p >Elasticsearch verwendet einen neueren und viel weniger aggressiven Algorithmus (Porter2), der in der Industrie breite Akzeptanz gefunden hat und allgemein als signifikante Verbesserung angesehen wird (Lancaster ist jetzt selten). Die Änderung des Stemmers wirkt sich möglicherweise auf einen erheblichen (~35 %) Anteil der Suchanfragen aus: das heißt nicht, dass die Ergebnisse <strong>Wille</strong> anders sein, nur dass sie <strong>Macht</strong> anders sein – aber im Allgemeinen sollte dies zum Besseren sein: Einige Untergruppen von Kunden können jedoch auf das alte Verhalten angewiesen sein.</p>
    
    <h3>Relevanz</h3>
    
    <p >Unsere bestehende Suche scheint eine strengere TF-Normalisierung zu haben. Dies führt zu einer anderen Relevanz-Sortierung für Begriffe, die in größeren Feldern gefunden werden (dh existierend betrachtet die Übereinstimmung als weniger relevant, da sie dem Begriff weniger Gewicht verleiht, da er im Verhältnis zur Länge des Dokuments kleiner ist).</p>
    
    <h3>Spezielle Charaktere</h3>
    
    <p >Sonderzeichen werden in unserer bestehenden Suche entfernt, dies entspricht so ziemlich dem Entfernen von Satzzeichen und verwandten Zeichen – anstatt sie zu entfernen, werden sie im Allgemeinen in Elasticsearch mit Escape-Zeichen versehen, daher besteht die Möglichkeit, dass eine Suche sie stattdessen berücksichtigt.</p>
    
    <h3>Umgang mit Begriffen</h3>
    
    <p >Bestehende Suchanfragen führen `Term Smoosing` durch, während wir in Elasticsearch fehlerhafte Begriffe löschen. Betrachten Sie diese Suche mit einem leeren <code translate="No">tags:</code> Begriff: <code translate="No">q=tags: state:ACTIVE</code></p>
    
    <ul>
      <li><strong>Bestehende</strong> : <code translate="No">tags:state:ACTIVE</code> — Suche nach Videos mit dem Tag <code translate="No">state:ACTIVE</code></li>
      <li><strong>Elasticsearch</strong> : <code translate="No">state:ACTIVE</code> — lass den leeren Begriff weg</li>
    </ul>
    
    <p >Es gibt eine Reihe von subtilen Grenzfällen im Zusammenhang mit der Handhabung von hängenden Satzzeichen und Abfragen, die im Allgemeinen falsch formatiert sind. wenn wir wirklich einen Fehler hätten zurückgeben sollen, der es ihnen ermöglicht, ihre Suche zu verfeinern)</p>
    
    <h3>Nur spielbar</h3>
    
    <p >Es gibt zwei Mechanismen, um eine Suche auf Videos einzuschränken, die derzeit abspielbar sind: Die Abfrage kann ein Flag enthalten oder die Abfrage selbst kann einen Aspekt der Abspielbarkeit erfordern.</p>
    
    <ul>
      <li>Vorhanden: Dies wird basierend auf dem Wert eines aktualisierten Felds abgefragt</li>
      <li>Elasticsearch: Dies wird basierend auf berechneten Datumsbereichen abgefragt</li>
    </ul>
    
    <p >Elasticsearch sollte im Allgemeinen genauer sein und bessere Ergebnisse liefern (der vorhandene Mechanismus ist mit einer Verzögerung verbunden, und der Mechanismus zur Flagpflege ist nicht ganz zuverlässig).</p>
    
    <h3>Indexgenauigkeit</h3>
    
    <p >Der Elasticsearch-Index ist „neuer“ als der vorhandene Index und neigt dazu, Aktualisierungen schneller wiederzugeben – dies ist nicht immer der Fall, aber im Allgemeinen haben die Ergebnisse mit Elasticsearch die Erfahrung gemacht, dass die Ergebnisse den Zustand der zugrunde liegenden Katalogdaten genauer widerspiegeln. Sowohl vorhandene als auch Elasticsearch sind verteilte Systeme und daher in den von ihnen zurückgegebenen Ergebnissen nicht vollständig konsistent: Eine wiederholte Abfrage eines der beiden Systeme kann möglicherweise unterschiedliche Ergebnisse zurückgeben (insbesondere, wenn mehrere Löschvorgänge gleichzeitig ausgeführt werden).</p>
    
    <p >Vorhandene Suchergebnisse ändern sich basierend auf dem Status des Shards, dem ein Konto zugeordnet ist – der globale Status eines bestimmten Shards kann (und tut) sich auf die Ergebnisse einer bestimmten Abfrage auswirken: Elasticsearch hat diesen Mangel nicht.</p>
    </section>
    
    <section class="bcls-section">
    <h2 id="Examples">Beispiele</h2>
    
    <h3>Beispiel 1</h3>
    
    <p >Nehmen wir an, es gibt zwei Videos mit den folgenden Titeln:</p>
    
    <pre>
      <code class="language-html" translate="No">Video#1: has the title “Don’t look into the light”
      Video#2: has the title “Using a lighter to make a campfire”</code></pre>
    
    <p >Der Benutzer möchte alle Videos zurückgeben, die das Wort „Licht“ enthalten müssen. Mit der CMS-API würde die Abfrage wie folgt aussehen:</p>
    
    <pre>
      <code class="language-html" translate="No">q=%2Blight or q=+light</code></pre>
    
    <p >Bei der bestehenden Suche werden beide Videos in der folgenden Reihenfolge zurückgegeben:</p>
    
    <pre>
      <code class="language-html" translate="No">Video#2 - “Using a lighter to make a campfire”
      Video#1 - “Don’t look into the light”</code></pre>
    
    <p >Dabei gibt es zwei Probleme:</p>
    
    <ul>
      <li><strong>Relevanz</strong>: Die Reihenfolge ist falsch. „Schau nicht ins Licht“ (Video Nr. 2) sollte vor „Mit einem Feuerzeug ein Lagerfeuer machen“ (Video Nr. 1) erscheinen.</li>
      <li><strong>Genauigkeit</strong>: „Mit einem Feuerzeug ein Lagerfeuer machen“ sollte nicht einmal in der Ergebnismenge erscheinen, da das Wort „Licht“ im Videotitel überhaupt nicht vorkommt.</li>
    </ul>
    
    <p >Mit Elasticsearch gibt dies nur Video eins zurück:</p>
    
    <pre>
      <code class="language-html" translate="No">Video#1 - “Don’t look into the light”</code></pre>
    
    <p >Dies ist eine Verbesserung, denn:</p>
    
    <ul>
      <li>Relevanz: Die Reihenfolge ist richtig.</li>
      <li>Genauigkeit: Es wird nur Video 1 zurückgegeben, da es das einzige Video mit dem Wort „light“ im Titel ist.</li>
    </ul>
    
    <h3>Beispiel 2</h3>
    
    <p >Wie in unserem beschrieben <a href="/cms/searching/cms-and-playback-apis-video-search-v2.html#Stemming">CMS-API-Dokumentation für das Stemming</a> , Wortstammung wird unterstützt, aber keine Suche nach Teilwörtern. Nehmen wir an, es gibt 5 Videos mit den folgenden Titeln:</p>
    
    <pre>
      <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
      Video#2 - "Parking to be Banned"
      Video#3 - "City Banning Parking"
      Video#4 - "Bank Holiday"
      Video#5 - "Bandit Captured"</code></pre>
    
    <p >Der Benutzer möchte alle Videos zurückgeben, die das Wort enthalten müssen <strong>Verbot</strong> im Namensfeld. Mit der CMS-API würde die Abfrage wie folgt aussehen:</p>
    
    <pre>
      <code class="language-html" translate="No">q=%2Bname%3Aban or q=+name:ban</code></pre>
    
    <p >Es wird erwartet, dass „Ban“, „Banning“ und „Banned“ Suchergebnisse erzeugen würden, da „Ban“ ein Stamm von allen dreien ist.</p>
    
    <p >Mit dem aktuellen Suchsystem werden jedoch alle fünf Videos in dieser Reihenfolge zurückgegeben:</p>
    
    <pre>
      <code class="language-html" translate="No">Video#2 - "Parking to be Banned"
      Video#3 - "City Banning Parking"
      Video#1 - "Parking Ban Announced"
      Video#4 - "Bank Holiday"
      Video#5 - "Bandit Captured"</code></pre>
    
    <p >Auch hier gibt es zwei Probleme:</p>
    
    <ul>
      <li>Relevanz: Die Reihenfolge ist falsch. "Parkverbot angekündigt" sollte das erste Video sein, das zurückgegeben wird, da es das Wort "Verbot" enthält.</li>
      <li>Genauigkeit: "Bank Holiday" und "Bandit Captured" sollten überhaupt nicht zurückgegeben werden, da "Ban" nicht Teil des Wortes "Bank" oder "Bandit" ist.</li>
    </ul>
    
    <p >Mit Elasticsearch sehen die Ergebnisse wie folgt aus:</p>
    
    <pre>
      <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
      Video#2 - "Parking to be Banned"
      Video#3 - "City Banning Parking"</code></pre>
    
    <p >Dies ist eine Verbesserung, denn:</p>
    
    <ul>
      <li>Relevanz: Die Reihenfolge ist richtig.</li>
      <li>Genauigkeit: Es werden nur Videos mit den Wortstämmen „Ban“ („Ban“, „Banning“ und „Banned“) zurückgegeben.</li>
    </ul>
    </section>
    </article>
 